---
title: 红黑树
excerpt: 数据结构-树-红黑树介绍
categories:
- 算法
tags:
- 算法
- 数据结构
- 树
- 红黑树
comments: true
layout: post
index_img: /img/jetbrain/1920x1080-space2022_1.png
abbrlink: 3929952611
date: 2022-05-22 00:15:24
---

# 概念

红黑树就是二叉搜索树:`Binary Search Tree，BST`但是特殊之处在于它是自平衡（动态平衡）的[二叉搜索树](/posts/2065787451.html#二叉搜索树)，在进行元素节点插入和删除时，会破坏树的平衡，需要重新自我进行旋转，从而达到平衡

>它是由`Rudolf Bayer`于1972年发明，当时被称为对称二叉B树(`symmetric binary B-trees`)。
>后来，在1978年被`Leo J. Guibas`和`Robert Sedgewick`改称为如今的红黑树


# 特点

前述[树](/posts/2065787451.html)的篇章也有说到[红黑树](/posts/2065787451.html#红黑树)，这里再次展开说明一下，让大家能更加清晰红黑树的概念

1. 每节点要么是黑色，要么是红色
2. 根节点是黑色
3. 每个叶子节点（`NIL`）是黑色
4. 每个红色节点的两个子节点和父节点一定都是黑色（从每个叶子节点到根节点的所有路径上不能有两个连续的红色节点）
5. 任意一节点到每个叶子节点的路径都包含数量相同的黑色节点（有时又被称之为**黑高**）
   从5又可推理出
6. 如果一个节点存在黑色子节点，那么该节点肯定有两个子结点

下图是一颗简单的红黑树。其中`Nil`为叶子节点，且是黑色的

![简单的红黑树](img/blackred/86697534BF749C2B4C174E3E925C4F30.jpg)

>注意: 在Java中，叶子节点为null

具备这些特点的目的，前述也已说明，是为了对树用尽量少的调整次数达到适度的平衡（自平衡/动态平衡）

这里通常会有一道面试题
## 为啥红黑树中，任意节点到其每个叶子节点路径最长长度不会超过最短路径的2倍？

**原因**
当某条路径最短时，这条路径必然都由黑色节点组成。当某条路径长度最长时，这条路径必然是由红色和黑色节点相间构成（前述特点4限定了不能出现两个连续的红色节点）。而特点5又限定了从任一节点到其每个叶子节点的所有路径必须包含相同数量的黑色节点，即黑高永远相等。那么在路径最长的情况下，路径上红色节点数=黑色节点数。该路径长度为两倍黑色节点数，也就是最短路径长度的2倍

如图所示

![原因](img/blackred/68068E262AB1734E22028F52EE3A9D0B.jpg)

红黑树最早被称为对称二叉B树，从名字中可发现红黑树和B树（这里指的是`2-3-4`树）有一定的关联。前述[树](/posts/2065787451.html)的篇章也有说明和图示，细节这里就不展开说明，有兴趣的可见[《算法》第4版](https://weread.qq.com/web/bookDetail/7cc32910718ff66b7cc8d9d)相关章节，已经说的很透彻了

## 代码展示

``` java
public class RBTree<T> {
  public T value;

  public RBTree<T> parent;

  public RBTree<T> left;

  public RBTree<T> right;

  public boolean isRed;
}
```

# 平衡操作

前述[树](/posts/2065787451.html)的篇章也有说明，这里再强调一下

所谓平衡，就是当节点数量固定时，左右子树的高度越接近，说明越平衡（高度越低）

红黑树达到平衡状态，有2种操作: 旋转和变色

## 旋转

旋转又分左旋还是右旋，在记述这两种旋转操作前，先对红黑树节点有个定义，方便后续说明

如图所示

![节点定义](img/blackred/49D3D1C9A5D7B0FF3A2A47ABEB06897B.jpg)

正在遍历的节点叫做当前节点，如图中的D，它的父亲叫做父节点，它的父亲的另外一个子节点叫做兄弟结点，父亲的父亲叫做祖父节点

### 左旋

以某个节点作为支点(旋转节点)，其右节点变为旋转节点的父节点，右节点的左节点变为旋转节点的右节点，左节点保持不变

![左旋](img/blackred/548359A0A721BA32911EE8D3148903FA.jpg)

### 右旋
以某个节点作为支点(旋转节点)，其左节点变为旋转节点的父节点，左节点的右节点变为旋转节点的左节点，右节点保持不变

![右旋](img/blackred/7FBB39177951D4D95DC12E12C2B6040F.jpg)

### 旋转总结

* 旋转操作不会影响旋转节点的父节点，父节点以上的结构还是保持不变
* 左旋只影响旋转节点和其右子树的结构，把右子树的节点挪给左子树了
* 右旋只影响旋转节点和其左子树的结构，把左子树的节点挪给右子树了

所以旋转操作是局部的。

旋转之所以能保持红黑树平衡原因在于**当一边子树的节点少了，那么向另外一边子树“借”一些节点；当一边子树的节点多了，那么向另外一边子树“租”一些节点**

但要保持红黑树的特点，节点不能乱挪，所以还需变色

## 变色

变色指的是节点颜色由红变黑或由黑变红，主要在红黑树插入，删除元素时，为了保证前述几个特点，而进行变色操作，保证可以自平衡（当然也免不了会进行左旋，右旋操作）

这里不做过多说明，见下文插入、删除元素操作

>注意: 文字和图如果还理解不了，这里分享一个链接[红黑树动态演示增删查和遍历](https://www.cs.usfca.edu/~galles/visualization/RedBlack.html)
>有兴趣的可以打开网页，自行进行元素添加，删除操作看看是否符合前述这些情况中的说明

# 插入元素操作

有几种情况
1. 新节点就是根节点: 直接让新节点变色为黑色(红黑树特点2)
2. 新节点的父节点为黑色: 新插入的红色节点并没有打破红黑树的特点5限制，黑高不变，所以不需做任何操作
3. 新节点的父节点和以及父节点的兄弟节点都为红色: 父节点和父节点的兄弟节点变黑，它们的父节点也就是祖父节点变红
4. 新节点的父结点为红色，父节点的兄弟节点为黑色或没有兄弟节点，且新节点是父节点的右子树，父节点是祖父节点的左子树: 以父节点为旋转节点，左旋。使新节点变为其原来父节点的新父节点，这样就变成马上要说的情况5
5. 新节点的父结点为红色，父节点的兄弟节点为黑色或没有兄弟节点，且新结点是父节点的左子树，父节点是祖父节点的左子树: 以祖父节点为旋转节点,右旋。使父节点变为其原来父节点（祖父节点）的新父节点，父节点变黑，原祖父节点变红
6. 新节点的父结点为红色，父节点的兄弟节点为黑色或没有兄弟节点，且新节点是父节点的右子树，父节点是祖父节点的右子树: 以祖父节点为旋转节点,左旋。使父节点变为其原来父节点（祖父节点）的新父节点，父节点变黑，原祖父节点变红
7. 新节点的父结点为红色，父节点的兄弟节点为黑色或没有兄弟节点，且新结点是父节点的左子树，父节点是祖父节点的右子树: 以父节点为旋转节点，右旋。使新节点变为其原来父节点的新父节点，这样就变成情况6

图示情况3-7
情况3
节点D为新节点，节点B为父节点，节点C为父节点的兄弟节点，节点A为祖父节点
父节点变黑

![父节点变黑](img/blackred/84E67706B690DE83DA01A5FB19A45A00.jpg)

祖父节点变红

![祖父节点变红](img/blackred/00855B55D5AAF67ED183D88FA12D34C0.jpg)

父节点的兄弟节点变黑

![父节点的兄弟节点变黑](img/blackred/9A06DDC67518FBE2FD889A1D1D79FFC5.jpg)

情况4
以父节点为旋转节点，左旋。使新节点变为其原来父节点的新父节点，变成情况5

![情况4->情况5](img/blackred/236A6CE2521CD8E482ACFB94583D50A0.jpg)

情况5
以祖父节点为旋转节点,右旋。使父节点变为其原来父节点（祖父节点）的新父节点。节点B变为节点A的父节点

![右旋](img/blackred/C42BE98D84F7C37A162345CB443C2CD0.jpg)

父节点变黑，原祖父节点变红

![父节点变黑，原祖父节点变红](img/blackred/56486109BE5799F707F6604128829D53.jpg)

情况6
节点I为新节点，节点P为父节点，父节点没有兄弟节点，且节点I是节点P的右子树，节点G是祖父节点，父节点P为祖父节点G的右子树
以祖父节点G为旋转节点,左旋。使父节点P变为祖父节点G的新父节点。然后节点P变黑，节点G变红

![左旋](img/blackred/83DBC38A785BD2690BF8E904BD7A8044.jpg)

情况7
节点I为新节点，节点P为父节点，P为红色，父节点没有兄弟节点，且节点I是节点P的左子树，节点G是祖父节点，父节点P为祖父节点G的右子树

![情况7](img/blackred/FD7343523FF88B16BDD3986DD02DA253.jpg)

以父节点P为旋转节点，右旋。使节点I变为其原来父节点P的新父节点，节点P变为新节点，这样就变成情况6

![情况7->情况6](img/blackred/74AC709E2354120241E5F7E053294E0C.jpg)

按照情况6进行旋转和变色

![按照情况6进行旋转和变色](img/blackred/4DB5518C72F6D2104392B70666C15282.jpg)

## 总结

根据新节点的父节点、它的兄弟节点以及祖父节点颜色，组合使用旋转和变色操作来完成插入元素操作。复杂的也就是3-7这5种情况，请细品。

接下来，我要开始说明删除元素操作了哦，这可是红黑树里最复杂，最难理解的操作。

坐好了，我要开始发车了~

# 删除元素操作

先不管颜色，不管颜色红黑树就是一个二叉搜索树，我们看看二叉搜索树的删除元素操作场景

1. 若删除节点无子节点，直接删除
2. 若删除节点只有一个子节点，用子节点替换删除节点
3. 若删除节点有两个子节点，用**后继节点，即大于删除节点的最小节点**替换删除节点

如图3种删除场景转换

![3种删除场景转换](img/blackred/28411D20580D08B62A87D8369B60007E.jpg)

看图可知场景2和3可以通过相互转换变为场景1

* 场景2
删除节点用其唯一的子节点替换，子节点替换为删除节点后，可以认为删除的是子节点，若子节点又有两个子节点，那么相当于转换为场景3，一直自顶向下转换，总是能转换为场景1

* 场景3
删除节点用后继节点，如果后继节点有右子节点，那么相当于转换为场景2，否则转为场景1

由此可知，删除节点可看作删除替换节点，且替换节点最后总是在叶子节点这里

接着看红黑树删除元素情况，在这之前定义好节点类型，以便说明

![先定义节点类型](img/blackred/A2CA49696972ABAD1B13EB73975923DC.jpg)

* R: 替换节点
* P: 替换节点的父节点
* S: 替换节点的兄弟节点
* SL: 兄弟节点的左子节点
* SR: 兄弟节点的右子节点
* 灰色: 节点颜色可能是红色，也可能是黑色

## 情况1: 替换节点为红色

替换节点换到删除节点的位置时，由于替换节点为红色，删除也了不会影响红黑树的平衡（黑高永远不变），只要把替换节点颜色变为删除节点颜色即可重新平衡

## 情况2: 替换节点为黑色

细分有很多情况

### 替换节点为左子树

1. 替换节点的兄弟节点为红色
![替换节点的兄弟节点为红色](img/blackred/AF1DD38268E946C74389ECF39F8C1E58.jpg)
若兄弟节点为红色，根据红黑树特点4，兄弟节点的父节点和子节点肯定为黑色，将兄弟节点变黑，父节点变红，对父节点进行左旋，得到本节删除情况2.3
![得到删除情况2.3](img/blackred/F7E711C14DFDD2DA693FAFB7666F712B.jpg)

2. 替换节点的兄弟节点为黑色
   兄弟节点为黑色，其父节点和子节点的具体颜色无法确定，此时得考虑多种子情况
   2.1 替换节点的兄弟节点的右子节点为红色，左子节点任意颜色(左+右为黑+红、红+红）
   ![2.1](img/blackred/CC009DAFB3209ED657F81540038A4DBE.jpg)
   即将删除的左子树的一个黑色节点，显然左子树的黑色节点少1了，然而右子节点又是红色，那么我们直接向右子树“借”个红节点来补充黑节点，并进行旋转处理。
   将兄弟节点的颜色变为父节点的颜色，将父节点变黑，将兄弟节点的右子节点变黑，对父节点左旋
   2.2 替换节点的兄弟节点的右子节点为黑色，左子节点为红色(左+右为红+黑）
   兄弟节点所在的子树有红节点，又可以向兄弟子树“借”个红节点过来，回到本节删除情况2.1
   将兄弟节点变红，将兄弟节点的左子节点变黑
   ![将兄弟节点变红，将兄弟节点的左子节点变黑](img/blackred/4BEDB049560867E664B486DE01B7C561.jpg)
   对兄弟节点进行右旋，回到本节删除情况2.1
   ![对兄弟节点进行右旋，回到本节删除情况2.1](img/blackred/485AFB69D98E64AED456909B4CC12D6C.jpg)
   2.3 替换节点的兄弟节点的子节点都为黑色(左+右为黑+黑）
   兄弟子树没有红节点可以“借”了，再向父节点“借”！
   如果父节点为黑色，为了让父节点在所在的子树中保证平衡（替换节点即将删除，少了一个黑色节点，子树也需要少一个）先把兄弟节点变为红色，再让父节点成为新的替换节点，然后重新进行二叉搜索树删除节点的场景处理
   如果父节点为红色，替换节点的父节点和替换节点的兄弟节点颜色交换；删除节点和替换节点的值交换后，删除替换节点。
   ![删除节点和替换节点的值交换后，删除替换节点](img/blackred/17C32BA222F55EF2D346A48A5A072FA6.jpg)

### 替换节点是右子树

1. 替换节点的兄弟节点为红色
将兄弟节点变黑，将父节点变红
![将兄弟节点变黑，将父节点变红](img/blackred/3764B48903BAD3D6731F04A800BCD8E6.jpg)
对父节点进行右旋，得到本节删除情况2.3
![对父节点进行右旋，得到本节删除情况2.3](img/blackred/60EBCB8E42142DB9B256567FAC16D7F6.jpg)

2. 替换节点的兄弟节点为黑色
   2.1 替换节点的兄弟节点的左子节点为红色，右子节点任意颜色(左+右为红+黑、红+红）
   将兄弟节点的颜色变为父节点的颜色，将父节点变黑，将兄弟节点的左子节点变黑，对父节点右旋
   ![将兄弟节点的颜色变为父节点的颜色，将父节点变黑，将兄弟节点的左子节点变黑，对父节点右旋](img/blackred/D2B46F79EB7BB7E51AD9FF56AE0721C7.jpg)
   2.2 替换节点的兄弟节点的左子节点为黑色，右子节点为红色(左+右为黑+红）
   ![将兄弟节点变红，将兄弟节点的右子节点变黑，对兄弟节点进行左旋，回到本节删除情况2.1](img/blackred/E475F3ACEB012C20C51C6C2D2C371C96.jpg)
   将兄弟节点变红，将兄弟节点的右子节点变黑，对兄弟节点进行左旋，回到本节删除情况2.1
   2.3 替换节点的兄弟节点的子节点都为黑色(左+右为黑+黑）
   如果父节点为黑色，将兄弟节点变为红色，再让父节点成为新的替换节点，然后重新进行二叉搜索树删除节点的场景处理
   如果父节点为红色，替换节点的父节点和替换节点的兄弟节点颜色交换；删除节点和替换节点的值交换后，删除替换节点
   ![替换节点的兄弟节点的子节点都为黑色(左+右为黑+黑）](img/blackred/34E7A0D6D0EAD75AF44607EBE289FE9E.jpg)

## 练习

![删除问题练习](img/blackred/3C3976E5C3C70AB378FF6209A1BB1DFA.jpg)

该图我要删除黑色节点17怎么玩？

解题步骤

1. 先不管颜色，按照二叉搜索树删除元素操作场景来看，这是属于场景3，找后续节点，就是比删除节点大的数字里面最小的那个，就是25

2. 25替换要删除的17，变成下图
![步骤2](img/blackred/D81CF60CFC9645446E6FF279A8022033.jpg)
25是要被替换的节点，15是它兄弟节点，16是它兄弟节点的右子节点，且是红色的，25本身是在右子树这里。那么就是替换节点是右子树章节中的删除情况2.2

3. 那么将兄弟节点15变红，将兄弟节点15的右子节点16变黑，对兄弟节点15进行左旋，得到下图
![步骤3](img/blackred/1E56A684B0FE535480A92F80963679C1.jpg)
这里替换节点25已经被删除掉了，其实这张图不对，应该nil节点还是替换节点25，这个时候就变成替换节点是右子树章节中的删除情况2.1

4. 将兄弟节点16的颜色变为父节点25的颜色，将父节点25变黑，将兄弟节点16的左子节点15变黑，对父节点25右旋.由于兄弟节点16和父节点25本来就是黑的，我们只要把15变黑，然后25右旋，得到下图
![步骤4](img/blackred/FAC7336EF05402168B8D30FFFA53B7B9.jpg)

5. 其实这时才应该删除上图虚线框的替换节点25为`nil`节点，最后总的红黑树图如下
![步骤5](img/blackred/962F24901942F4D797320983B2B6EDBB.jpg)

## 总结

删除操作先不管颜色，判断属于二叉搜索树中的哪种删除场景，然后再根据替换节点所处左右子树位置以及兄弟节点、父节点颜色来判断如何删除

# 补充说明

以下分享一下我用java源码实现的红黑树，使用java11编写，加入了大量中文注释，可对照前述章节查看插入，删除元素操作过程

一共三个类

* RBTreeNode.java 红黑树节点类
* RBTree.java 红黑树类，包括遍历，插入和删除操作
* RBTreeRunner.java 红黑树运行类，执行main方法，打印出红黑树结构

main方法输出格式如下:

``` log
d(黑;;)	
b(黑;d;左)	g(红;d;右)	
a(红;b;左)	e(黑;g;左)	h(黑;g;右)	
f(红;e;右)
```

括号左边表示节点值。括号内用分号间隔表示**颜色;父节点值;位置**，颜色分红黑两种，位置分左右两种

第一个节点d是根节点，根节点没有父节点，所以括号内只有颜色表示

## 源码

见 [红黑树(java11版)](https://gitee.com/darkranger/beating-interviewer/tree/master/src/main/java/com/wujunshen/algorithm/rbtree)

# 参考资料

1. [红黑树动态演示增删查和遍历](https://www.cs.usfca.edu/~galles/visualization/RedBlack.html)
2. [漫画: 什么是红黑树？](https://mp.weixin.qq.com/s/652xl0kH_po4kSXgFLgn3Q)
3. [红黑树在HashMap中的应用](https://mp.weixin.qq.com/s/XEJD5eyfo1Kz3tDZGepBcQ)
4. [ConcurrentHashMap的红黑树实现分析](https://mp.weixin.qq.com/s/5e1LdYr9Mdmh85rUyTMdhw)
5. [红黑树(java11版)](https://gitee.com/darkranger/beating-interviewer/tree/master/src/main/java/com/wujunshen/algorithm/rbtree)

# [推荐书单](/algorithm)
